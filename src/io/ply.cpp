#define TINYPLY_IMPLEMENTATION

#include "pcr/io/ply.hpp"
#include "pcr/io/tinyply.h"
#include "pcr/io/tinyply_utils.hpp"

namespace pcr::io::ply {


// This implementation is largely based on the example.cpp code file given in
// the tinyply repository, it has simply been modified to present a
// simplified API for my use case
void write_file(const std::string &path_to_file,
                const core::PointCloud &src_point_cloud, const bool binary) {

  // Initialize outstream
  std::filebuf fb;
  binary ? fb.open(path_to_file + ".ply", std::ios::out | std::ios::binary)
         : fb.open(path_to_file + ".ply", std::ios::out);
  std::ostream outstream(&fb);
  if (outstream.fail())
    throw std::runtime_error("failed to open " + path_to_file);

  // Pack points from src_point_cloud into a flat vertex_buffer of x,y,z coords
  // to be passed to tinyply
  std::vector<core::PointCloud::coordinate_value_type> vertex_buffer;
  vertex_buffer.reserve(src_point_cloud.size() * 3);
  for (const auto &point : src_point_cloud) {
    vertex_buffer.push_back(point.x);
    vertex_buffer.push_back(point.y);
    vertex_buffer.push_back(point.z);
  }

  // Use tinyply API to write vertex_buffer to the outstream
  tinyply::PlyFile new_ply_file;
  new_ply_file.add_properties_to_element(
      "vertex", {"x", "y", "z"}, tinyply::Type::FLOAT32, src_point_cloud.size(),
      reinterpret_cast<uint8_t *>(vertex_buffer.data()), tinyply::Type::INVALID,
      0);
  new_ply_file.get_comments().emplace_back("generated by tinyply 3.0");

  // Write ply file
  binary ? new_ply_file.write(outstream, true)
         : new_ply_file.write(outstream, false);
}

} // namespace pcr::io::ply